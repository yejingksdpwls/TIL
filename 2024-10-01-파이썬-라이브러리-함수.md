## *객체지향

- 객체 : 클래스의 인스턴스, 실제로 생성된 구체적인 데이터와 기능을 가지는 실체
- 객체지향 프로그래밍(OOP) : 클래스와 객체를 사용해 프로그램 설계/구현
- OOP 핵심원칙
    - 캡슐화 : 객체의 속성/메서드를 하나로 묶고 일부를 외부어 감춰 객체 내부 숨김
    - 상속 : 기존 클래스를 기반으로 새로운 클래스 만듦
    - 다형성 : 동일한 이름의 메서드가 객체에서 다르게 동작할 수 있음
    - 추상화 : 복잡한 시스템 단순화, 필요한 부분만 보여줌
          &nbsp;
## *사용자 클래스

- 클래스 정의
    
    class 클래스 이름:
    
    클래스 속성/메서드 정의
    
    pass  # 클래스 비어있을 때 사용 (선택적)
    

- 속성 : 객체의 상태/특성 나타내는 변수
    - __init__ (클래스 생성자 메서드)으로 정의 → 객체 생성될 때 자동으로 호출됨

```
ex)

class AI_student:

def __init__(self, input_name)

self.name = input_name

—> n = AI_student(”Alice”) 라고 했을 때, n .name 부분에 “Alice” 값 저장됨
```
         
 &nbsp;
## *메서드

- 매직 메서드 : 특별한 역할을 수행하는 미리 정의된 메서드
    - __init__ : 객체의 초기화
    - __repr__ : 객체의 “공식적인” 문자열 표현 반환
    - __add__ : 객체 간의 덧셈 연산 정의 ( + 연산자 재정의 )
        
        → ex) 그냥 ‘abc’ + ‘def’ 하면 오류 발생하는데, 
        
        def __add__(self, other):
        
        print(self.name + other.name) 
        
        이렇게 정의하고 실행하면 덧셈 연산 가능
        
    - __eq__ : 객체 비교 ( 위와 동일한 원리 ) ( == 연산자 재정의 )
    - __str__ : 객체의 “비공식적인” 문자열 표현 반환

- 클래스 메서드 : 클래스 자체를 인수로 받는 메서드
    - 클래스 변수 : 클래스 내에서 정의한 변수 ( 클래스/클래스가 만든 객체 모두 공유 )
        
        → 한 번 정의되면 변하지 않음
        
    - 클래스 메서드
        - @클래스메서드

- 정적 메서드 : 클래스/객체와는 관련 없지만 클래스 맥락에서 의미 있는 메서드
    - 첫 번째 매개변수로 self, cls를 받지 않음
    
    ```
    ex) 
    
    class Utility:
    
    @staticmethod
    
    def add(x,y):
    
    return x+y
    
    → Utility와 add 함수 간의 연관성은 없지만 맥락에서 의미 있는 경우로 정적 메서드로 이어줌
    
&nbsp;
## * 파일 읽기/쓰기

- “r” : 읽기 전용
- “w” : 쓰기 전용 → 내용을 덮어씀 (주의📢)
- “a” : 원본에 이어서 쓰기
- 주의사항
    - 파일 경로 확인
    - 파일 모드 확인
    - 파일 닫기
    - 예외 처리
			&nbsp;
### *이터레이터

- 반복 가능한 객체 (iterable) : 하나씩 차례대로 값을 꺼내올 수 있는 객체
    
    ```
    ex) 반복 가능한 객체 예시
    
    list = [1,2,3]
    
    for i in list:
    
    print(i)
    
- 이터레이터 : 반복 가능한 객체의 요소를 하나씩 꺼내오는 객체
    
    → a = iter(리스트) : 리스트로부터 이터레이터 생성
    
    → next(a) : 이터레이터의 각 요소 하나씩 추출
    
&nbsp;
### *제너레이터

- 이터레이터를 생성하는 특별한 함수
- ‘yield’ 키워드를 통해 값 하나씩 반환
- 필요할 때마다 값 생석해 메모리 효율성이 높음

```
ex) 

def s_generator():

yield 1

yield 2

yield 3

—> print(next(s_generate())) #1

—> print(next(s_generate())) #2
```
&nbsp;
### *데코레이터

- 함수나 메서드를 변경하지 않고, 추가적인 기능을 쉽게 추가할 수 있는 방법
- @decorator_function 처럼 생성 가능
		&nbsp;
## *Django

- Python 기반의 고수준 웹 프레임워크

- 특징
    - 개발이 빠름
    - 보안 문제 예방 가능
    - 확장성
    - DRY 원칙 (Don’t Repeat Yourself) : 중복 코드 최소화 함
    
- 주요 구성 요소
    - 모델 : 데이터 베이스 구조 정의
    - 뷰 : 사용자가 보는 화면
    - 템플릿 : HTML 생성
    - URL 컨퍼그 : URL과 뷰 연결
    
- 기본적 동작 흐름
    
    → URL 요청 → 뷰 호출 → 데이터 처리 및 템플릿 렌더링 → HTML 응답
    
- MVT 패턴 : Django에서 사용하는 아키텍처 패턴 (웹 애플리케이션 기본 구조 정의)
    - 모델 : 데이터 구조/처리 로직 정의
    - 뷰 : 비즈니스 로직, 데이터 처리 담당
    - 템플릿 : 사용자에게 보여질 화면 정의 (HTML 파일)
    - 장점
        - 명확한 역할 부담
        - 재사용성과 확장성
        - 테스트 용이성

- MVT 패턴 동작 흐름
    
    → URL 요청 → 뷰 연결/호출 → 데이터 조회/처리 → 템플릿 생성 → HTML 응답 반환
    

# < Pandas >

- 데이터를 쉽게 다룰 수 있게 해주는 데이터 분석 라이브러리

```
import pandas as pd
```
&nbsp;
- 데이터 프레임 : 행/열로 구성된 2차원 데이터 구조

```
data = {

‘A’ : [1,2,3],

‘B’ : [4,5,6]

} #딕셔너리 생성

df = pd.DataFrame(data) #데이터프레임 구조로 변환

→ 값의 개수가 맞지 않으면 데이터프레임으로 변환 시 오류 발생 (주의📍)

→ 인덱스/컬럼명을 통해 데이터에 접근 가능

df[’A’][0]
```
&nbsp;
- 시리즈 : 단일 열을 나타내는 1차원 데이터 구조

```
sample = pd.Series([1,2,3], index = [’A’, ‘B’, ‘C’] )
```

→ index : 값 각각의 이름

→ sample[’A’] : 인덱스를 이용해 값에 빠르게 접근할 수 있음

→ 데이터 타입 자동으로 설정되지만, 원하는 타입으로 변경 가능
		&nbsp;
# < NumPy >

- 과학 계산에 강력한 성능 제공
- 특징
    - 고속 배열 연산  (C언어로 작성되어 있음 )
    - 다양한 수학 함수
    - 선형대수, 통계함수 제공
- np.array : 배열

    → 벡터화 연산 가능 (반복문 없이 배열 전체에 연산 적용 가능)
    → shape : 배열의 형상 (튜플 형태) 출력
    → ndim : 차원 출력
    → size : 배열 개수 출력
    → reshape : 데이터의 형상 변경 가능
    → ravel : 1차원으로 변경 가능 (원본에 영향 O)
    → flatten : 1차원으로 변경 가능 (원본에 영향 X)